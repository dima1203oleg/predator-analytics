name: Nightly re-run important workflows

on:
  schedule:
    # Run daily at 03:00 UTC to re-check stability of key workflows
    - cron: '0 3 * * *'
  workflow_dispatch:

jobs:
  dispatch-key-workflows:
    name: Nightly rerun of failed runs + reporting
    runs-on: ubuntu-latest
    concurrency:
      group: nightly-rerun
      cancel-in-progress: false
    env:
      TARGET_BRANCH: main
      REPORT_ISSUE_TITLE: Nightly rerun report
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find latest failed run and optionally re-run (per-workflow)
        id: rerun
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner
            const repo = context.repo.repo
            const branch = process.env.TARGET_BRANCH || 'main'
            const workflows = ['deploy.yml','deploy-mac.yml','deploy-nvidia.yml','deploy-oracle.yml']

            const allowedBadConclusions = new Set(['failure','timed_out','cancelled','action_required','startup_failure'])
            const retryLimit = 3 // max attempts for the same run

            const summary = []

            for (const wf of workflows) {
              core.info(`Checking latest completed runs for workflow ${wf} on branch ${branch}`)
              const runsResp = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: wf, branch, per_page: 10, status: 'completed' })
              const runs = runsResp.data.workflow_runs || []

              // choose the most recent non-successful run
              const lastFailed = runs.find(r => r.conclusion !== 'success')

              if (!lastFailed) {
                summary.push({ workflow: wf, status: 'ok', reran: 0 })
                continue
              }

              const runAttempt = lastFailed.run_attempt || 1
              if (!allowedBadConclusions.has(lastFailed.conclusion)) {
                core.info(`Found failure of type ${lastFailed.conclusion}, skipping rerun for ${wf}`)
                summary.push({ workflow: wf, status: 'problem', reran: 0, reason: `conclusion=${lastFailed.conclusion}` })
                continue
              }

              if (runAttempt >= retryLimit) {
                core.info(`Run ${lastFailed.id} for ${wf} already tried ${runAttempt} times (>=${retryLimit}), not re-running`)
                summary.push({ workflow: wf, status: 'problem', reran: 0, reason: `attempts=${runAttempt}` })
                continue
              }

              // Re-run the single most-recent failed run
              core.info(`Re-running run ${lastFailed.id} for ${wf} (conclusion=${lastFailed.conclusion}, attempt=${runAttempt})`)
              await github.rest.actions.reRunWorkflowRun({ owner, repo, run_id: lastFailed.id })

              summary.push({ workflow: wf, status: 're-ran', reran: 1, run_id: lastFailed.id, conclusion: lastFailed.conclusion, url: lastFailed.html_url })
            }

            return JSON.stringify(summary)

      - name: Create/update nightly rerun report issue
        if: always()
        uses: actions/github-script@v7
        env:
          SUMMARY_JSON: ${{ steps.rerun.outputs.result }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner
            const repo = context.repo.repo
            const title = process.env.REPORT_ISSUE_TITLE || 'Nightly rerun report'
            const createdAt = new Date().toISOString()
            const summary = JSON.parse(process.env.SUMMARY_JSON || '[]')

            // compute overall status
            const problemCount = summary.filter(s => s.status !== 'ok' && s.status !== 're-ran').length
            const overall = problemCount === 0 ? 'OK' : 'PROBLEMS'

            const bodyLines = [
              `Overall status: **${overall}**`,
              '',
              `Nightly rerun summary ‚Äî ${createdAt}`,
              '',
            ]

            for (const s of summary) {
              if (s.status === 'ok') {
                bodyLines.push(`- ${s.workflow}: ‚úÖ OK ‚Äî no recent failures`)
              } else if (s.status === 're-ran') {
                bodyLines.push(`- ${s.workflow}: üîÅ Re-ran run <${s.url}|#${s.run_id}> (previous conclusion: ${s.conclusion})`)
              } else {
                bodyLines.push(`- ${s.workflow}: ‚ö†Ô∏è Problem ‚Äî ${s.reason || 'see details'}`)
              }
            }

            const body = bodyLines.join('\n')

            // Find an existing open issue with the same title
            const { data: issues } = await github.rest.issues.listForRepo({ owner, repo, state: 'open', per_page: 100 })
            const found = issues.find(i => i.title === title)
            if (found) {
              await github.rest.issues.createComment({ owner, repo, issue_number: found.number, body })
              core.info(`Appended nightly summary to issue #${found.number}`)
            } else {
              const res = await github.rest.issues.create({ owner, repo, title, body })
              core.info(`Created nightly summary issue #${res.data.number}`)
            }

      - name: Optional ‚Äî post to Slack if webhook is configured
        if: ${{ env.SLACK_WEBHOOK != '' }}
        env:
          SUMMARY: ${{ steps.rerun.outputs.result }}
        run: |
          echo "Posting summary to Slack"
          payload=$(jq -n --arg txt "Nightly rerun: $SUMMARY" '{text: $txt}')
          curl -sS -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK"
